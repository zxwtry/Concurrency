01, 应该掌握的技术点
    1,  使用wait/notify实现线程间的通信
    2,  生产者/消费者模式的实现
    3,  方法join的使用
    4,  ThreadLocal类的使用

02, wait()方法
    1,  方法wait()的作用：使执行当前代码的线程等待。
        wait()是Object类的方法。
        wait()将当前线程置入"预执行队列"中。
        当前线程在wait()处停止执行，直到接到通知或被中断为止。
    2,  调用wait()之前，线程必须获取该对象的对象级锁，
        即只能在同步方法或同步块中调用wait()方法。
        执行wait()方法后，当前线程释放锁。
        在从wait()返回前，线程与其它线程竞争重新获得锁。
    3,  如果调用wait()时，没有持有适当的锁，
        则抛出IllegalMonitorStateException，
        它是RuntimeException的一个子类，
        不需要try-catch

03, notify()方法
    1,  同样在同步方法或同步方法块中，
        调用前，线程也必须获得该对象的对象级锁。
    2,  如果调用notify()时，没有持有适当的锁，
        也会抛出IllegalMonitorStateException。
    3,  notify()用来通知那些可能等待该对象对象锁的其它线程。
        如果有多个线程等待，则由线程规划器选择出一个，
        对其发出notify通知。
    4,  执行notify()后，当前线程不会马上释放对象锁，
        呈wait状态的线程也不能马上获取该对象锁。
        要等到notify()所在的synchronized代码执行完。
    5,  当第一个获得了该对象锁的wait线程运行完毕之后，
        它会释放该对象锁，此时如果该对象没有再次使用notify语句，
        则即使该对象已经空闲，其它wait状态等待的线程
        由于没有得到该对象的通知，还会继续阻塞在wait状态，
        直到该对象发出一个notify或notifyAll。
    6,  notifyAll()方法：使所有正在等待队列中等待同一共享资源的
        "全部"线程从等待状态退出，进入可运行状态。

04, 线程状态：new Thread()
    1,  新建一个线程对象，再调用start()方法，
    2,  系统会为此线程分配CPU资源，使其处于Runnable(可运行)状态。
    3,  这是一个准备运行的阶段。如果抢到CPU资源，此线程处于Running状态。

05, 线程状态：Blocked(阻塞)
    1,  线程调用sleep方法，主动放弃占用的CPU资源。
    2,  线程调用阻塞IO方法。
    3,  线程试图获得一个同步监视器，但该同步监视器正被其它线程所持有。
    4,  线程执行了某个对象的wait方法，等待某个notify。
    5,  程序调用suspend方法。(不推荐使用)

06, 线程状态：进入Runnable
    1,  调用sleep方法，sleep超过指定的休眠时间。
    2,  线程调用的阻塞IO已经返回，阻塞方法执行完毕。
    3,  线程成功地获得了该同步监视器。
    4,  线程正在等待某个notify(通知)，其它线程发出了通知。 
    5,  处于挂起状态的线程调用了resume(恢复)方法。


