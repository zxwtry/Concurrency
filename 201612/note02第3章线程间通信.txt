01, 应该掌握的技术点
    1,  使用wait/notify实现线程间的通信
    2,  生产者/消费者模式的实现
    3,  方法join的使用
    4,  ThreadLocal类的使用

02, wait()方法
    1,  方法wait()的作用：使执行当前代码的线程等待。
        wait()是Object类的方法。
        wait()将当前线程置入"预执行队列"中。
        当前线程在wait()处停止执行，直到接到通知或被中断为止。
    2,  调用wait()之前，线程必须获取该对象的对象级锁，
        即只能在同步方法或同步块中调用wait()方法。
        执行wait()方法后，当前线程释放锁。
        在从wait()返回前，线程与其它线程竞争重新获得锁。
    3,  如果调用wait()时，没有持有适当的锁，
        则抛出IllegalMonitorStateException，
        它是RuntimeException的一个子类，
        不需要try-catch

03, notify()方法
    1,  同样在同步方法或同步方法块中，
        调用前，线程也必须获得该对象的对象级锁。
    2,  如果调用notify()时，没有持有适当的锁，
        也会抛出IllegalMonitorStateException。
    3,  notify()用来通知那些可能等待该对象对象锁的其它线程。
        如果有多个线程等待，则由线程规划器选择出一个，
        对其发出notify通知。
    4,  执行notify()后，当前线程不会马上释放对象锁，
        呈wait状态的线程也不能马上获取该对象锁。
        要等到notify()所在的synchronized代码执行完。
    5,  当第一个获得了该对象锁的wait线程运行完毕之后，
        它会释放该对象锁，此时如果该对象没有再次使用notify语句，
        则即使该对象已经空闲，其它wait状态等待的线程
        由于没有得到该对象的通知，还会继续阻塞在wait状态，
        直到该对象发出一个notify或notifyAll。
    6,  notifyAll()方法：使所有正在等待队列中等待同一共享资源的
        "全部"线程从等待状态退出，进入可运行状态。

04, 线程状态：new Thread()
    1,  新建一个线程对象，再调用start()方法，
    2,  系统会为此线程分配CPU资源，使其处于Runnable(可运行)状态。
    3,  这是一个准备运行的阶段。如果抢到CPU资源，此线程处于Running状态。

05, 线程状态：Blocked(阻塞)
    1,  线程调用sleep方法，主动放弃占用的CPU资源。
    2,  线程调用阻塞IO方法。
    3,  线程试图获得一个同步监视器，但该同步监视器正被其它线程所持有。
    4,  线程执行了某个对象的wait方法，等待某个notify。
    5,  程序调用suspend方法。(不推荐使用)

06, 线程状态：进入Runnable
    1,  调用sleep方法，sleep超过指定的休眠时间。
    2,  线程调用的阻塞IO已经返回，阻塞方法执行完毕。
    3,  线程成功地获得了该同步监视器。
    4,  线程正在等待某个notify(通知)，其它线程发出了通知。 
    5,  处于挂起状态的线程调用了resume(恢复)方法。

07, 线程状态：销毁阶段
    run方法运行结束后，进入销毁阶段，整个线程执行结束。

08, 每个锁对象都有两个队列：就绪队列和阻塞队列。
    1,  就绪队列存储将要获得锁的线程。
    2,  阻塞队列存储被阻塞的线程。
    3,  一个线程被唤醒后，才会进入就绪队列，等待CPU的调度。
    4,  一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。

09, 生产者和消费者的实现一：一个生产者+一个消费者+一个缓存区
    1,  基本回顾：
            P操作 ---> 申请资源
            V操作 ---> 释放资源
            P(s)  ---> if s==0 wait else s=s-1
            V(s)  ---> s=s+1
    2,  定义两个同步信号量
            empty ---> 缓存区是否为空，初值1(代表缓存区大小)
            full  ---> 缓存区是否已满，初值0
            mutex ---> 临界区互斥信号量
    3,  两个线程：
        生产者线程：
            while(true) {
                生产一个产品
                P(empty);
                P(mutex);
                产品送往缓冲区
                V(mutex);
                V(full);
            }
        消费者线程：
            while(true) {
                P(full);
                P(mutex);
                从缓冲区取出一个产品
                V(mutex);
                V(empty);
                消费该产品
            }

10, 通过管道进行线程间通信：字节流
    1,  管道流(pipeStream)是一种特殊的流，
        用于在不同线程间直接传送数据。
    2,  一个线程发送数据到输出管道，
        另一个线程从管道中读数据。
        通过使用管道，实现不同线程间通信，
        无须借助于类似临时文件之类的东西。
    3,  JDK中提供4个类来使线程间进行通信：
        a,  PipedInputStream和PipedOutputStream
        b,  PipedReader和PipedWriter
    4,  代码见：Code12_通过管道进行线程间通信_字符流.java

11, 方法join的使用
    1,  在很多情况下，主线程创建并启动子线程。
        如果子线程中要进行大量的耗时运算，主线程往往早于子线程结束。
    2,  如果主线程想等待子线程执行完成之后再结束。
        join的作用：等待线程对象销毁。
    3,  a.join();在b线程中执行。
        b会进行无期限的阻塞，等待线程a销毁后再继续执行b线程后面的代码。
    4,  方法join具有使线程排队运行的作用，有些类似同步的运行效果。
        join方法内部使用wait()方法进行等待。
        synchronized关键字使用的是"对象监视器"原理做同步。
    5,  在b线程中：a.start(); a.join();
        在c线程中：b.interrupt()
        当b线程处于等待a结束时，b.interrutp()和b.join()会出现异常。
        这时，b线程停止，a线程仍在运行，c线程仍在运行。
    6,  join(long): 在b线程中，a.join(100); b的对象锁会释放。
        sleep(long): 在b线程中，Thread.sleep(100); b的对象锁不会释放。
    
